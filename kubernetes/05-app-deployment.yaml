apiVersion: apps/v1
kind: Deployment
metadata:
  name: todo-flask-app       # Name of your application deployment
  namespace: todo-app-ns    # IMPORTANT: Must match the namespace defined in 00-namespace.yaml
                            # and the K8S_NAMESPACE environment variable in your main.yml
spec:
  replicas: 1               # Number of pods (instances) for your application
  selector:
    matchLabels:
      app: todo-flask-app   # Selector to link deployment to pods
  template:
    metadata:
      labels:
        app: todo-flask-app # Labels for the pods
    spec:
      containers:
      - name: todo-flask-container # IMPORTANT: This must match the container name
                                   # used in the 'kubectl set image' command in main.yml
        image: my-app:latest       # The image name and tag built locally by Minikube's Docker daemon
        imagePullPolicy: Never     # CRUCIAL for Minikube CI: Don't pull from remote registry
        ports:
        - containerPort: 8080      # The port your Flask application listens on (e.g., Gunicorn bind port)
        env: # Example: Environment variables for your Flask app to connect to the DB
        - name: DATABASE_HOST      # Name of environment variable in your Flask app
          value: todo-db-service   # Name of your database Kubernetes Service (e.g., from 04-db-service.yaml)
        - name: DATABASE_USER
          valueFrom:
            secretKeyRef:
              name: db-credentials # Name of your Kubernetes Secret (from 01-db-secret.yaml)
              key: username        # Key within the Secret
        - name: DATABASE_PASSWORD
          valueFrom:
            secretKeyRef:
              name: db-credentials
              key: password
        # Add resource limits, probes, etc., if desired
        resources:
          requests:
            cpu: "100m"
            memory: "128Mi"
          limits:
            cpu: "200m"
            memory: "256Mi"